# 81. 搜索旋转排序数组 II
## 一、题目描述
假设按照升序排序的数组在预先未知的某个点上进行了旋转。

( 例如，数组 `[0,0,1,2,2,5,6]` 可能变为 `[2,5,6,0,0,1,2]` )。

编写一个函数来判断给定的目标值是否存在于数组中。若存在返回 `true`，否则返回 `false`。

```
输入: nums = [2,5,6,0,0,1,2], target = 0
输出: true
```

## 二、思路
### 1. 直接遍历
```cpp
class Solution {
public:
    bool search(vector<int>& nums, int target) {
        for (int i = 0; i < nums.size(); ++i) {
            if (nums[i] == target) {
                return true;
            }
        }
        return false;
    }
};
```
时间复杂度：$O(n)$；
空间复杂度：$O(1)$.

### 2. 二分查找
与`33`题类似，都是搜索旋转排序数组中的目标元素。但是此题中含有重复元素，因此，在基于二分排序的基础上还需要添加一下细节。

从`33`题可知，要确定下一个查找区间在哪里，首先要确定`mid`区分的两个区间哪个有序，根据有序的一部分确定查找的区间。但是，当`nums[mid] == nums[left]`或者`nums[mid] == nums[right]`时，是无法确定哪边的区间有序的。例如：

|0|1|2|3|4|5|6|7|
|-|-|-|-|-|-|-|-|
|4|4|4|7|1|4|4|4|
若`mid = 6`，此时`nums[left] == nums[mid]`，左侧无序；
若`mid = 1`，此时`nums[left] == nums[mid]`，左侧有序。
`nums[mid] == nums[right]`同理。

因此，`nums[mid] == nums[left]`或`nums[mid] == nums[right]`时不能确定哪一侧有序，因此，在遇到这种情况时，只能通过`++left`或者`--right`来一步一步缩进区间。

```cpp
class Solution {
public:
    bool search(vector<int>& nums, int target) {
        int left = 0, right = nums.size() - 1;
        while (left <= right) {
            int mid = (left + right) >> 1;
            if (target == nums[mid]) {
                return true;
            }
            if (nums[mid] == nums[left]) {
                ++left;
                continue;
            }
            if (nums[mid] == nums[right]) {
                --right;
                continue;
            }
            if (nums[mid] > nums[left]) {
                if (nums[mid] > target && target >= nums[left]) {
                    right = mid - 1;
                } else {
                    left = mid + 1;
                }
            } else {
                if (nums[mid] < target && target <= nums[right]) {
                    left = mid + 1;
                } else {
                    right = mid - 1;
                }
            }
        }

        return false;
    }
};
```
时间复杂度：$O(\log n)$；
空间复杂度：$O(1)$。
