# 365. 水壶问题
## 一、题目描述
有两个容量分别为`x`升和`y`升的水壶以及无限多的水。请判断能否通过使用这两个水壶，从而可以得到恰好`z`升的水？

如果可以，最后请用以上水壶中的一或两个来盛放取得的`z`升水。
你允许：

- 装满任意一个水壶
- 清空任意一个水壶
- 从一个水壶向另外一个水壶倒水，直到装满或者倒空

```
输入: x = 3, y = 5, z = 4
输出: True
```

## 二、思路
此题是个数学题。但是此题有多种解法。
### 1. DFS
首先，有两个容量为`x`和`y`的容器。在任意时刻，我们可以对这两个容器进行以下的操作中的其中一种：

- 倒满`x`
- 倒满`y`
- 倒空`x`
- 倒空`y`
- 将`x`中的水倒入`y`中直至倒满
- 将`y`中的水倒入`x`中直至倒满

因此，可以使用`DFS`进行操作。用`remain_x`和`remain_y`表示容器`x`和容器`y`当前的水量。那么只有当`remain_x == target`或者`remain_y == target`或者`remain_x + remain_y == target`。但是在`DFS`过程中可能会操作到相同的两种状态，此时则会导致无线递归。因此可以用一个`set`等容器存储出现过的状态，以使每一种状态都只会出现一次。

```cpp
class Solution {
private:
    using pii = pair<int, int>;
    int x, y;
    bool myFunc(int remain_x, int remain_y, int z, set<pii>& s) {
        if (remain_x + remain_y == z) {
            return true;
        }

        bool status1 = false, status2 = false, status3 = false, 
             status4 = false, status5 = false, status6 = false;
        if (s.find(make_pair(x, remain_y)) != s.end()) {
            status1 = false;
        } else {
            s.emplace(make_pair(x, remain_y));
            status1 = myFunc(x, remain_y, z, s);
        }

        if (s.find(make_pair(remain_x, y)) != s.end()) {
            status2 = false;
        } else {
            s.emplace(make_pair(remain_x, y));
            status2 = myFunc(remain_x, y, z, s);
        }

        if (s.find(make_pair(0, remain_y)) != s.end()) {
            status3 = false;
        } else {
            s.emplace(make_pair(0, remain_y));
            status3 = myFunc(0, remain_y, z, s);
        }

        if (s.find(make_pair(remain_x, 0)) != s.end()) {
            status4 = false;
        } else {
            s.emplace(make_pair(remain_x, 0));
            status4 = myFunc(remain_x, 0, z, s);
        }

        int tmp_x = remain_x - min(remain_x, y - remain_y);
        int tmp_y = remain_y + min(remain_x, y - remain_y);
        if (s.find(make_pair(tmp_x, tmp_y)) != s.end()) {
            status5 = false;
        } else {
            s.emplace(make_pair(tmp_x, tmp_y));
            status5 = myFunc(tmp_x, tmp_y, z, s);
        }

        tmp_x = remain_x + min(remain_y, x - remain_x);
        tmp_y = remain_y - min(remain_y, x - remain_x);
        if (s.find(make_pair(tmp_x, tmp_y)) != s.end()) {
            status6 = false;
        } else {
            s.emplace(make_pair(tmp_x, tmp_y));
            status6 = myFunc(tmp_x, tmp_y, z, s);
        }

        return (status1 || status2 || status3 || status4 || status4 || status5 || status6);

    }
public:
    bool canMeasureWater(int x, int y, int z) {
        set<pii> s;
        this->x = x;
        this->y = y;
        if (x + y == z || x == z || y == z) {
            return true;
        }
        if (x + y < z) {
            return false;
        }
        
        return myFunc(0, 0, z, s);
        
    }
};
```
但是这样写会爆栈，因为当`x`和`y`特别大的时候，一直递归计算这六种状态的结果会导致递归深度太大。因此，可以考虑使用一个栈来实现递归的操作。
```cpp
class Solution {
private:
    using pii = pair<int, int>;
public:
    bool canMeasureWater(int x, int y, int z) {
        set<pii> s;
        stack<pii> st;
        if (x + y == z || x == z || y == z) {
            return true;
        }
        if (x + y < z) {
            return false;
        }
        
        st.emplace(make_pair(0, 0));
        while (!st.empty()) {
            pii p = st.top();
            st.pop();
            if (s.count(p)) {
                continue;
            }
            s.emplace(p);
            int remain_x = p.first, remain_y = p.second;

            if (remain_y == z || remain_x == z || remain_x + remain_y == z) {
                return true;
            }

            st.emplace(x, remain_y);
            st.emplace(remain_x, y);
            st.emplace(0, remain_y);
            st.emplace(remain_x, 0);
            st.emplace(remain_x - min(remain_x, y - remain_y), remain_y + min(remain_x, y - remain_y));
            st.emplace(remain_x + min(remain_y, x - remain_x), remain_y - min(remain_y, x - remain_x));

        }

        return false;
        
    }
};
```
即使这样写也有`TLE`风险。

### 2. 裴蜀定理
对于每次操作而言，我们都可以认为这次操作让两个桶的水的总量增加/减少了`x`或者增加/减少了`y`。虽然其中可能出现未满非空桶，但是：

- 每次操作之后不可能出现两个未满非空桶；
- 向未满非空桶里加满水是没有意义的，因为如果另一个桶为空，则该操作就等价于直接向该桶加满水；如果另一个桶为满，则该操作等价于向两个桶里直接加满水；
- 将未满桶里的水倒掉也是没有意义的，因为如果另一个桶是空的，那么这个操作的结果等价于回到初始状态；而如果另一个桶是满的，那么这个操作的结果等价于从初始状态直接给另一个桶倒满。

因此，我们完全可以认为每一次操作都相当于让两个桶的水的总量增加/减少了`x`或者增加/减少了`y`。也就是要找出某一对`a`和`b`，使得
$$ax+by=z\qquad \qquad (x + y \le z)$$
成立。

- 若$a\le0$，则进行以下操作：
  
  - 将`y`倒满
  - 将`y`倒入`x`
  - 若`y`未空，则`x`必满。此时直接倒掉`x`，再将`y`倒入`x`；若`y`空，则直接倒掉`x`即可。
  重复以上三步，直到倒掉了`a`次`x`，倒入了`b`次`y`。
- 若 $b\le 0$ ，则进行操作同上。
- 若 $a\ge0$，$b\ge0$ ，则直接倒入即可。（很显然，$a\le1$，$b\le1$）.

由裴蜀定理，可以得知，当且仅当 $z$ 是 $x$ 和 $y$ 的最大公约数的倍数时， $ax+by=z$ 有解。

```cpp
class Solution {
private:
    int gcd(int a, int b) {
        if (!b) {
            return a;
        }
        return gcd(b, a % b);
    }
public:
    bool canMeasureWater(int x, int y, int z) {
        if (x + y < z) {
            return false;
        }

        if (!x) {
            return y == z;
        }

        if (!y) {
            return x == z;
        }

        return z % gcd(x, y) == 0;
    }
};
```