# 1631. 最小体力消耗路径
## 一、题目描述
你准备参加一场远足活动。给你一个二维` rows x columns `的地图` heights `，其中` heights[row][col] `表示格子` (row, col) `的高度。一开始你在最左上角的格子` (0, 0) `，且你希望去最右下角的格子` (rows-1, columns-1)` （注意下标从` 0 `开始编号）。你每次可以往**上，下，左，右**四个方向之一移动，你想要找到耗费体力最小的一条路径。

一条路径耗费的体力值是路径上相邻格子之间**高度差绝对值**的**最大值**决定的。

请你返回从左上角走到右下角的最小体力消耗。

```
输入：heights = [[1,2,2],[3,8,2],[5,3,5]]
输出：2
解释：路径 [1,3,5,3,5] 连续格子的差值绝对值最大为 2 。
这条路径比路径 [1,2,2,2,5] 更优，因为另一条路径差值最大值为 3 。
```

```
输入：heights = [[1,2,1,1,1],[1,2,1,2,1],[1,2,1,2,1],[1,2,1,2,1],[1,1,1,2,1]]
输出：0
```

**1** 2 **1** **1** **1**
**1** 2 **1** 2 **1**
**1** 2 **1** 2 **1**
**1** 2 **1** 2 **1**
**1** **1** **1** 2 **1**
```
解释：上图所示路径不需要消耗任何体力。
```

`rows == heights.length`
`columns == heights[i].length`
`1 <= rows, columns <= 100`
`1 <= heights[i][j] <= 1000000`


## 二、思路
因为可以上下左右四个方向移动，因此无法用动态规划求解。第一种思路是二分查找。
### 1. 二分法
因为路径总长度不会超过$(100 + 100) \times 1000000 = 2e 8$，因此上界可设置为$2\times10^8$，下界可设为$0$。由题意可知，只要选择的路径中高度差最大的两个相邻元素之差小于`mid`，则该路径则是可行的。

对于二分法的其中一个中间结果`mid`，若消耗`mid`的体力可以从左上到右下，则记录当前结果，因为该结果可以满足从左上游到右下的条件，然后设置右边界为`mid - 1`，否则设置左边界为`mid + 1`。

要判断是否能够从左上到右下，可以采用`BFS`。

```cpp
class Solution {
private:
    const int DIR[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
public:
    int minimumEffortPath(vector<vector<int>>& heights) {
        int res = 0;
        int left = 0, right = 1e6 - 1;
        int row = heights.size(), col = heights[0].size();
        while(left <= right) {
            int mid = (left + right) >> 1;
            queue<vector<int>> q;
            q.push({0, 0});
            int visited[row][col];
            memset(visited, 0, sizeof(visited));
            visited[0][0] = 1;

            while(!q.empty()){
                auto root = q.front();
                q.pop();
                for(int i = 0; i < 4; ++i) {
                    int next_x = root[0] + DIR[i][0];
                    int next_y = root[1] + DIR[i][1];
                    if(next_x >= 0 && next_x < row && next_y >= 0 && next_y < col && !visited[next_x][next_y] && abs(heights[root[0]][root[1]] - heights[next_x][next_y]) <= mid) {
                        q.push({next_x ,next_y});
                        visited[next_x][next_y] = 1;
                    }
                }
            }

            if(visited[row - 1][col - 1]) {
                    res = mid;
                    right = mid - 1;
            } else {
                    left = mid + 1;
            }
        }

        return res;
    }
};
```
时间复杂度：$\Omicron(mn\log N)$；$m$和$n$是行数和列数，$N$是取的`right`的值，因为二分过程中需要进行$\log n$次循环。
空间复杂度：$\Omicron(mn)$。

### 2. 并查集
换一种思路，可以按照贪心的思路，将所有的边（上下左右的权值差）先从小到大排序，然后按顺序加入到并查集中，直到左上和右下连通。
```cpp
// 并查集模板
class UnionFind {
public:
    vector<int> parent;
    vector<int> size;
    int n;
    // 当前连通分量数目
    int setCount;
    
public:
    UnionFind(int _n): n(_n), setCount(_n), parent(_n), size(_n, 1) {
        //iota(parent.begin(), parent.end(), 0);
        for (int i = 0; i < _n; ++i) {
            parent[i] = i;
        }
    }
    
    int find(int x) {
        return parent[x] == x ? x : parent[x] = find(parent[x]);
    }
    
    bool unite(int x, int y) {
        x = find(x);
        y = find(y);
        if (x == y) {
            return false;
        }
        if (size[x] < size[y]) {
            swap(x, y);
        }
        parent[y] = x;
        size[x] += size[y];
        --setCount;
        return true;
    }
    
    bool connected(int x, int y) {
        x = find(x);
        y = find(y);
        return x == y;
    }
};

struct EDGE{
    int x, y, weight;
    EDGE(int _x, int _y, int _w) : x(_x), y(_y), weight(_w) {}
    bool operator< (const EDGE& u) const{
        return weight < u.weight;
    }
};

class Solution {
public:
    int minimumEffortPath(vector<vector<int>>& heights) {
        int m = heights.size();
        int n = heights[0].size();
        //vector<tuple<int, int, int>> edges;
        vector<EDGE> edges;
        for (int i = 0; i < m; ++i) {
            for (int j = 0; j < n; ++j) {
                int id = i * n + j;
                if (i > 0) {
                    edges.emplace_back(id - n, id, abs(heights[i][j] - heights[i - 1][j]));
                }
                if (j > 0) {
                    edges.emplace_back(id - 1, id, abs(heights[i][j] - heights[i][j - 1]));
                }
            }
        }
        
        sort(edges.begin(), edges.end());

        UnionFind uf(m * n);
        int ans = 0;
        for (const auto& e: edges) {
            uf.unite(e.x, e.y);
            if (uf.connected(0, m * n - 1)) {
                ans = e.weight;
                break;
            }
        }
        return ans;
    }
};
```
时间复杂度：$\Omicron(mn\log (mn))$；$m$和$n$是行数和列数，排序的时间复杂度是$\Omicron(mn\log (mn))$，并查集的时间复杂度是$\Omicron(mn\ \alpha (mn))$，后者小于前者，因此时间复杂度是$\Omicron(mn\log (mn))$；
空间复杂度：$\Omicron(mn)$。