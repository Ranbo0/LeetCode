# 914. 卡牌分组
## 一、题目描述
给定一副牌，每张牌上都写着一个整数。

此时，你需要选定一个数字 `X`，使我们可以将整副牌按下述规则分成 `1` 组或更多组：

每组都有 `X` 张牌。
组内所有的牌上都写着相同的整数。
仅当你可选的 `X >= 2` 时返回 `true`。

## 二、思路
### 1. 暴力枚举
直接从`2`开始枚举到`N`，因为要让整副牌的每组都有`X`张牌，所以`X`也要是`N`的约数。如果选定的`X`能够满足条件则返回`true`，否则返回`false`。

```cpp
class Solution {
    int count[10000];
public:
    bool hasGroupsSizeX(vector<int>& deck) {
        int N = (int)deck.size();
        for (int c: deck) count[c]++;

        vector<int> values;
        for (int i = 0; i < 10000; ++i) {
            if (count[i] > 0) {
                values.emplace_back(count[i]);
            }
        }

        for (int X = 2; X <= N; ++X) {
            if (N % X == 0) {
                bool flag = 1;
                for (int v: values) {
                    if (v % X != 0) {
                        flag = 0;
                        break;
                    }
                }
                if (flag) {
                    return true;
                }
            }
        }
        return false;
    }
};
```
时间复杂度：$O(n^2)$；
空间复杂度：$O(n)$.

### 2. gcd
由`1`可知，`X`要是`N`的约数。由此可推出，只有当所有的`count`都有`X`的约数时，卡组才能被分组。其中`count`表示每种元素的数量。

```cpp
class Solution {
private:
    int gcd(int a, int b) {
        if (!b) {
            return a;
        }
        return gcd(b, a % b);
    }
public:
    bool hasGroupsSizeX(vector<int>& deck) {
        int n = deck.size();
        if (n < 2) {
            return false;
        }
        unordered_map<int, int> mp;
        for (auto& d : deck) {
            mp[d]++;
        }
        int x = 0;
        for (auto it = mp.begin(); it != mp.end(); ++it) {
            x = gcd(it->second, x);
            if (x == 1) {
                return false;
            }
        }

        return x > 1;
    }
};
```
时间复杂度：$O(n\log C)$；
空间复杂度：$O(n)$.