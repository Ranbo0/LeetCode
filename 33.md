# 33. 搜索旋转排序数组
## 一、题目描述
整数数组 `nums` 按升序排列，数组中的值**互不相同** 。

在传递给函数之前，`nums` 在预先未知的某个下标 `k`（`0 <= k < nums.length`）上进行了**旋转**，使数组变为 `[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]`（下标**从 0 开始**计数）。例如， `[0,1,2,4,5,6,7]` 在下标 3 处经旋转后可能变为 `[4,5,6,7,0,1,2]` 。

```
输入：nums = [4,5,6,7,0,1,2], target = 0
输出：4
```

## 二、思路
### 1. 直接遍历
```cpp
class Solution {
public:
    int search(vector<int>& nums, int target) {
        for (int i = 0; i < nums.size(); ++i) {
            if (nums[i] == target) {
                return i;
            }
        }

        return -1;
    }
};
```
时间复杂度：$O(n)$；
空间复杂度：$O(1)$.

### 2. 二分查找
虽然数组部分有序，但是仍然可以通过与首尾元素比较从而得到有序的一部分。例如：
|0|1|2|3|4|5|6|7|
|-|-|-|-|-|-|-|-|
|4|5|6|7|0|1|2|3|
`mid = 3`，`nums[mid] = 7`，此时与`left = 0`比较，得到`nums[mid] >= nums[left]`，因此左侧必定有序。再例如`point = 5`，此时与`right = 7`比较，得到`nums[point] <= nums[right]`，因此右侧必定有序。

既然可以得到部分已知的有序数组，那么我们就可以以此为依据对区间进行划分。常规的二分查找是根据`mid`划分出来的`[left, mid)`和`(mid, right]`来确定下一步需要查找的区间，此时我们也可以通过`mid`划分出来的`[left, mid)`和`(mid, right]`中有序的那一部分来确定下一步要查找的区间，因为我们能够通过有序的部分确定`target`是否在这个区间之中。

+ 如果 `[l, mid - 1]` 是有序数组，且 `target` 的大小满足 `nums[target]∈[nums[l],nums[mid])`，则我们应该将搜索范围缩小至 `[l, mid - 1]`，否则在 `[mid + 1, r]` 中寻找。
+ 如果 `[mid + 1, r]` 是有序数组，且 `target` 的大小满足 `nums[target]∈(nums[mid],nums[r]]`，则我们应该将搜索范围缩小至 `[mid + 1, r]`，否则在 `[l, mid - 1]` 中寻找。

```cpp
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int n = nums.size();
        int left = 0, right = n - 1;

        while (left <= right) {
            int mid = (left + right) >> 1;
            if (nums[mid] == target) {
                return mid;
            }
            if (nums[mid] >= nums[left]) {
                if (nums[left] <= target && target < nums[mid]) {
                    right = mid - 1;
                } else {
                    left = mid + 1;
                }
            } else {
                if (nums[right] >= target && target > nums[mid]) {
                    left = mid + 1;
                } else {
                    right = mid - 1;
                }
            }
        }

        return -1;
    }
};
```
时间复杂度：$O(\log n)$；
空间复杂度：$O(1)$。