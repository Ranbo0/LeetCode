# 678. 有效的括号字符串
## 一、题目描述
给定一个只包含三种字符的字符串：`(`，`)`和`*`，写一个函数来检验这个字符串是否为有效字符串。有效字符串具有如下规则：

任何左括号` ( `必须有相应的右括号 `)`。
任何右括号` ) `必须有相应的左括号` ( `。
左括号` ( `必须在对应的右括号之前` )`。
* 可以被视为单个右括号` ) `，或单个左括号` ( `，或一个空字符串。
一个空字符串也被视为有效字符串。

## 二、思路
### 1. 栈
因为其中含有`*`，因此不能用一般的思路来判断括号是否成对。我们可以考虑用一个单独的栈`s`来记录`*`。因为需要对括号进行配对，因此需要记录的其实应该是括号和`*`出现的位置而不是括号本身。
两个栈分别将`(`和`*`的序号分别压入栈中，每次遇到右括号，首先检测左括号栈是否为空，不为空则弹出元素，否则检测星号栈是否为空，不为空则弹出元素。因为括号栈和星号栈可能存在元素，因此还要对括号栈和星号栈继续处理。判断此时两栈栈顶元素的序号大小，如果括号栈中的栈顶元素的序号大于星号栈中的栈顶元素的序号，则表明存在`*(`的情况，直接返回`false`，当括号栈为空时说明`*`的数量大于等于`(`的数量且每个`(`都能有一个`*`与之配对，否则说明有部分`(`都没有元素能与之配对。
```cpp
class Solution {
public:
    bool checkValidString(string str) {
        stack<int> left, s;
        for (int i = 0; i < str.size(); ++i) {
            if (str[i] == '(') {
                left.push(i);
            } else if (str[i] == '*') {
                s.push(i);
            } else {
                if (!left.empty()) {
                    left.pop();
                } else if (!s.empty()) {
                    s.pop();
                } else {
                    return false;
                }
            }
        }

        while (!left.empty() && !s.empty()) {
            if(left.top() > s.top()) {
                return false;
            }
            left.pop();
            s.pop();
        }

        return left.empty();
    }
};
```
时间复杂度：$O(n)$；
空间复杂度：$O(n)$.

### 2. 贪心算法
考虑一个变量`balance`，它表示未配对的左括号的数量。例如在`()()(())`中，`balance`的变化过程为：`[1, 0, 1, 0, 1, 2, 1, 0]`.当括号字符串中含有星号时，例如`(***)`，`balance`的变化情况为：`[1, [0, 1, 2], [0, 1, 2, 3], [0, 1, 2, 3, 4], [0, 1, 2, 3]]`.因为`*`可以代表`(`，`)`和空字符。我们可以将`balance`的变化情况堪称一系列区间：`[1, 1], [0, 2], [0, 3], [0, 4], [0, 3]`.其中，每个区间的左右边界分别表示可能的未匹配的左括号数量的最小值和最大值。分别用`low`和`high`表示。那么执行起来就是：
1. 遇到左括号：`low++`, `high++`;
2. 遇到星号：`low--`(如果`low > 0`的话), `high++`;
3. 遇到右括号：`low--`(如果`low > 0`的话), `high--`

在执行过程中，如果`high < 0`，则说明右括号在这个时候大于左括号和星号的总数量，直接返回`false`。执行完之后，如果`low > 0`，则说明去掉配对的括号之后右括号和星号的总和小于左括号的数量，返回`false`。

```cpp
class Solution {
public:
    bool checkValidString(string str) {
        int low = 0, high = 0;
        for (auto& c : str) {
            if (c == '(') {
                ++low;
                ++high;
            } else if (c == ')') {
                low = low ? low - 1 : 0;
                high--;
            } else {
                low = low ? low - 1 : 0;
                high++;
            }
            if (high < 0) {
                return false;
            }
        }
        
        return low == 0;
    }
};
```
时间复杂度：$O(n)$；
空间复杂度：$O(1)$.