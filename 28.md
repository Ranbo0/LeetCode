# 28. 实现`strStr()`
## 一、 题目描述

实现 ` strStr() ` 函数。

给你两个字符串 ` haystack ` 和 ` needle `，请你在 ` haystack ` 字符串中找出 `needle` 字符串出现的第一个位置（下标从 `0` 开始）。如果不存在，则返回  `-1` 。

注：当 `needle` 是空字符串时，函数应该返回 `0` ，这与 `C` 语言的 `strstr()` 函数和 `java` 的 `indexOf()` 是一致的。

## 二、 思路分析
### 1. 直接搜索
遍历 `haystack` ，找到能与 `needle` 匹配的位置即可。

```cpp
class Solution {
public:
    int strStr(string haystack, string needle) {
        int m = haystack.size(), n = needle.size();

        if (!n) {
            return 0;
        }

        for (int i = 0; i < m; ++i) {
            for (int j = 0; j < n; ++j) {
                if (haystack[i] != needle[j]) {
                    break;
                }
                if (j == n - 1) {
                    return i;
                }
            }
        }

        return -1;
    }

};

```
时间复杂度： $O(mn)$ ；
空间复杂度： $O(1)$ 。

### 2.  `KMP` 算法
对于主串 `haystack` 和模式串 `needle` ，可以利用已经部分匹配的信息，保证指针 `i` 不回溯（即 `haystack` 的指针），通过修改 `j` 指针从而让模式串竟可能移动到匹配长度最大的有效的位置上。

例如，主串为 `BBC ABCDAB ABCDABCDABD` ，模式串为 `ABCDABD` ， `KMP` 的匹配过程如下。

```
|B|BCABCDABABCDABCDABD      i = 0
|A|BCDABD                   j = 0

```

在第一个字符处不匹配，因此搜索后移一位。

```
B|B|CABCDABABCDABCDABD      i = 1
 |A|BCDABD                  j = 0
```

不匹配，再右移。

```
BBC|A|BCDABABCDABCDABD      i = 3
   |A|BCDABD                j = 0
```

直到搜索到一个字符与模式串的第一个字符匹配。然后比较模式串的下一个字符。

```
BBCABCDAB|A|BCDABCDABD      i = 10
   ABCDAB|D|                j = 6
```

一直匹配直到结束或者出现错误匹配的情况。

如果按照暴力匹配的方法，则是将主串的指针回溯到 `j + 1` 的地方重新开始匹配：

```
Brute match
BBCA|B|CDABABCDABCDABD      i = 4
    |A|BCDABD               j = 0
```

`KMP` 算法的思想就是通过前面匹配成功的已知信息，不要将 `i` 移回 `4` ，而是继续后移，只移动 `j` ，也就是说后移 `needle` 以提高效率。

要充分利用前面的信息，就要用到部分匹配表（ `Partial Match Table` ）。

首先用一个小例子观察 `j` 的移动过程：
```
|A|BCABCDHIJK...        i = 0
|A|BCACC                j = 0
```

```
ABCA|B|CDHIJK...        i = 5
ABCA|C|C                j = 5
```
此时 `C` 和 `B` 不匹配，要移动 `j` ，将 `j` 移动到哪里才最好呢，当然是 `1` 了，因为前面有一个 `A` 了，可以与 `i = 2` 匹配。

```
ABCA|B|CDHIJK...        i = 5
   A|B|CACC                j = 5
```

没有将 `i` 向后移动，而是移动 `j` ，使之重新匹配。而且这部分信息是可以由当前匹配情况得知的。因为模式串 `needle` 匹配到 `j` 时，那么必然有 `needle` 的 `needle[0...j - 1] == haystack[i - j...i - 1]` 。

再例如：

```
|A|BCABCDHIJK...        i = 0
|A|BCABB                j = 0
```

```
ABCAB|C|DHIJK...        i = 5
ABCAB|B|                j = 5
```

因为前面有 `AB` 是与 `j - 1` 前面的字符串是一样的，因此只需要将 `j` 移动到 `2` 处即可：

```
ABCAB|C|DHIJK...        i = 5
   AB|C|ABB             j = 5
```

也就是说：
当 `haystack[i] != needle[j]` 时，必然有：`haystack[i - j ... i - 1] == needle[0 ... j - 1]` ；而根据模式串 `needle` ，若得知 `needle[0 ... k - 1] == needle[j - k ... j - 1]` ，则必然有 `haystack[i - k ... i - 1] == needle[j - k ... j - 1]` 。

简而言之，只要我们能求出 `needle[0 ... k - 1] == needle[j - k ... j - 1]` 在所有的 `j` 的情况下能够取到的最大的 `k` ，即可通过 `kmp` 算法快速得到结果。而 `KMP` 算法的实质就是因为（部分）模式串的首尾会有重复，因此可以避免很多不必要的比较。

再简而言之，上述等式就是求前缀和后缀相等的最长的长度。例如：

```
string = "noodle"
prefix : "n", "no", "noo", "nood", "noodl"
suffix : "e", "le", "dle", "odle", "oodle"
```

上面简单介绍了前缀和后缀，下面再计算最长公共前后缀的长度。

例如：
```
string = "ABCDABD"
"A"          prefix = [], suffix = [], maxLen = 0;
"AB"         prefix = ["A"], suffix = ["B"], maxLen = 0;
"ABC"        prefix = ["A", "AB"], suffix = ["BC", "C"], maxLen = 0;
"ABCD"       prefix = ["A", "AB", "ABC"], suffix = ["BCD", "CD", "D"], maxLen = 0;
"ABCDA"      prefix = ["A", "AB", "ABC", "ABCD"], suffix = ["BCDA", "CDA", "DA", "A"], maxLen = 1;
"ABCDAB"     prefix = ["A", "AB", "ABC", "ABCD", "ABCDA"], suffix = ["BCDAB", "CDAB", "DAB", "AB", "B"], maxLen = 2;
"ABCDABD"    prefix = ["A", "AB", "ABC", "ABCD", "ABCDA", "ABCDAB"], suffix = ["BCDABD", "CDABD", "DABD", "ABD", "BD", "D"], maxLen = 0;
```

上述计算的 `maxLen` ，就是我们之前要得到的部分匹配表（ `Partial Match Table` ， `PMT` ）。

|搜索词|A|B|C|D|A|B|D|
|-|-|-|-|-|-|-|-|
|部分匹配值|0|0|0|0|1|2|0|

因为我们用到的都是当前字符前的最长前后缀，因此， `kmp` 的 `next` 数组是 `PMT` 向后偏移一位得到的。

|搜索词|A|B|C|D|A|B|D|
|-|-|-|-|-|-|-|-|
|<center>`PMT`</center>|0|0|0|0|1|2|0|
|<center>`next`</center>|-1|0|0|0|0|1|2|

之所以将 `next[0]` 设置成 `-1` ，是因为当匹配到 `needle` 的第一个字符都失败时，需要将 `i` 和 `j` 自增，而当 `haystack[i] == needle[j]` 时同样是将 `i` 和 `j` 自增，因此将 `next[0]` 设置成 `-1` 时，自增后的 `j` 是 `0` ，也就是 `needle` 的初始位置。

根据上述分析方法，得到 `next` 数组的算法如下：

```cpp
// next has been defined
void getNext(string needle) {
    next[0] = -1;
    int n = needle.size();

    int i = 0, j = -1;
    while (i < n - 1) {
        if (j == -1 || needle[i] == needle[j]) {
            ++i;
            ++j;
            next[i] = j;
        } else {
            j = next[j];
        }
    }
}
```
其实看起来还是有点让人迷糊，下面对于
```cpp
next[i] = j;
```
和
```cpp
j = next[j];
```
进一步细说。

首先，当 `needle[i] == needle[j]` 时，通过前文易知， `next[j + 1] = next[j] + 1` 。前面说的
> 当 `haystack[i] != needle[j]` 时，必然有：`haystack[i - j ... i - 1] == needle[0 ... j - 1]` ；而根据模式串 `needle` ，若得知 `needle[0 ... k - 1] == needle[j - k ... j - 1]` ，则必然有 `haystack[i - k ... i - 1] == needle[j - k ... j - 1]` 。

可以证明，将 `haystack` 替换成 `needle` 即可。这里直接画图更清晰：
```
ABCABCD     
  ^  ^
  |  |
  i  j
i = 2, j = 5
needle[2] == needle[5]
next[5 - 1] = 1, next[5] = 2
```

因此，当 `needle[i] == needle[j]` 时，通过前文易知， `next[j + 1] = next[j] + 1` 。在函数中表示出来就是
```cpp
++i;
++j;
next[i] = j;
// next[++i] = ++j;
```

如果 `needle[i] != needle[j]` ，那么：
```
...ABA|B|C...
   ABA|C|
```

```
...ABA|B|C...
     A|B|AC
```
参考的还是上面那段话：
> 当 `haystack[i] != needle[j]` 时，必然有：`haystack[i - j ... i - 1] == needle[0 ... j - 1]` ；而根据模式串 `needle` ，若得知 `needle[0 ... k - 1] == needle[j - k ... j - 1]` ，则必然有 `haystack[i - k ... i - 1] == needle[j - k ... j - 1]` 。

结合上述所述，可以看成是 `needle` 与自身进行匹配的过程。当匹配对象是 `haystack` 时，道理是差不多的。

```cpp
// next has been initialized by getNext()
int kmp(string haystack, string needle) {
    int m = haystack.size(), n = needle.size();
    if (!n) {
        return 0;
    }
    
    // i -- the location of haystack
    // j -- the location of needle
    int i = 0, j = 0;

    while (i < m && j < n) {
        if (j == -1 || haystack[i] == needle[j]) {
            ++i;
            ++j;
        } else {
            j = next[j];
        }
    }

    if (j == n) {
        return i - j;
    }
    return -1;

}
```

因此，该题也就迎刃而解了。

```cpp
class Solution {
private:
    void getNext(string& needle, vector<int>& next) {
        int n = needle.size();

        next[0] = -1;

        int i = 0, j = -1;
        while (i < n - 1) {
            if (j == -1 || needle[i] == needle[j]) {
                ++i;
                ++j;
                next[i] = j;
            } else {
                j = next[j];
            }
        }
    }
public:
    int strStr(string haystack, string needle) {
        int m = haystack.size(), n = needle.size();
        if (!n) {
            return 0;
        }

        vector<int> next(n);
        getNext(needle, next);

        int i = 0, j = 0;
        while (i < m && j < n) {
            if (j == -1 || haystack[i] == needle[j]) {
                ++i;
                ++j;
            } else {
                j = next[j];
            }
        }

        if (j == n) {
            return i - j;
        }
        return -1;
    }
};
```
时间复杂度： $O(n)$ ；
空间复杂度： $O(n)$ 。
