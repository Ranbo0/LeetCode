# 173. 二叉搜索树迭代器
## 一、题目描述
实现一个二叉搜索树迭代器类`BSTIterator` ，表示一个按中序遍历二叉搜索树（`BST`）的迭代器：
`BSTIterator(TreeNode root)` 初始化 `BSTIterator` 类的一个对象。`BST` 的根节点 `root` 会作为构造函数的一部分给出。指针应初始化为一个不存在于 `BST` 中的数字，且该数字小于` BST `中的任何元素。
`boolean hasNext()` 如果向指针右侧遍历存在数字，则返回 `true` ；否则返回 `false` 。
`int next()`将指针向右移动，然后返回指针处的数字。
注意，指针初始化为一个不存在于 `BST` 中的数字，所以对` next() `的首次调用将返回 `BST` 中的最小元素。

你可以假设` next() `调用总是有效的，也就是说，当调用 `next()` 时，`BST` 的中序遍历中至少存在一个下一个数字。

```
输入:
["BSTIterator", "next", "next", "hasNext", "next", "hasNext", "next", "hasNext", "next", "hasNext"]
[[[7, 3, 15, null, null, 9, 20]], [], [], [], [], [], [], [], [], []]
输出:
[null, 3, 7, true, 9, true, 15, true, 20, false]

        7
       / \
      3  15
        /  \
       9   20

解释
BSTIterator bSTIterator = new BSTIterator([7, 3, 15, null, null, 9, 20]);
bSTIterator.next();    // 返回 3
bSTIterator.next();    // 返回 7
bSTIterator.hasNext(); // 返回 True
bSTIterator.next();    // 返回 9
bSTIterator.hasNext(); // 返回 True
bSTIterator.next();    // 返回 15
bSTIterator.hasNext(); // 返回 True
bSTIterator.next();    // 返回 20
bSTIterator.hasNext(); // 返回 False
```

## 二、思路
很显然本题意在模拟中序遍历的序列，而且要得到某个元素之后的那个元素。因此，可以直接通过中序遍历得到该树的中序遍历序列，然后在调用`next()`或者`hasNext()`时直接按中序遍历序列得到结果即可。

### 1. 递归
```cpp
class BSTIterator {
private:
    vector<int> store;
    int index = 0;
    void inTraverse(TreeNode* root){
        if(root){
            inTraverse(root->left);
            store.push_back(root->val);
            inTraverse(root->right);
        }
    }
public:
    BSTIterator(TreeNode* root) {
        index = 0;
        store.resize(0);
        inTraverse(root);
    }
    
    int next() {
        return store[index++];
    }
    
    bool hasNext() {
        if(index < store.size()){
            return true;
        }
        return false;
    }
};
```
时间复杂度：$O(n)$；
空间复杂度：$O(n)$。

### 2. 迭代
因为是一个元素一个元素取值，所以无需维护所有节点，只需要维护当前状态即可。
```cpp

class BSTIterator {
private:
    TreeNode* cur;
    stack<TreeNode*> stk;
public:
    BSTIterator(TreeNode* root): cur(root) {}
    
    int next() {
        while (cur != nullptr) {
            stk.push(cur);
            cur = cur->left;
        }
        cur = stk.top();
        stk.pop();
        int ret = cur->val;
        cur = cur->right;
        return ret;
    }
    
    bool hasNext() {
        return cur != nullptr || !stk.empty();
    }
};
```
时间复杂度：$O(n)$；
空间复杂度：$O(n)$。

### 3. 只维护左子链
根据中序遍历的特征，可以只将左子链入栈。
```cpp
class BSTIterator {
private:
    stack<TreeNode*> s;
public:
    BSTIterator(TreeNode* root) {
        while (root) {
            s.push(root);
            root = root->left;
        }
    }
    
    int next() {
        TreeNode* tmp = s.top();
        s.pop();
        int ret = tmp->val;
        tmp = tmp->right;
        while (tmp) {
            s.push(tmp);
            tmp = tmp->left;
        }
        return ret;
    }
    
    bool hasNext() {
        return !s.empty();
    }
};
```
时间复杂度：$O(h)$；$h$表示树的最大高度。
空间复杂度：$O(n)$。