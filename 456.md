# 456. 132 模式
## 一、题目描述
给你一个整数数组` nums `，数组中共有` n `个整数。`132` 模式的子序列 由三个整数` nums[i]`、`nums[j]` 和 `nums[k]` 组成，并同时满足：`i < j < k` 和` nums[i] < nums[k] < nums[j] `。

如果` nums `中存在` 132 `模式的子序列 ，返回` true `；否则，返回` false `。

```
输入：nums = [1,2,3,4]
输出：false
解释：序列中不存在 132 模式的子序列。
```

```
输入：nums = [3,1,4,2]
输出：true
解释：序列中有 1 个 132 模式的子序列： [1, 4, 2] 。
```

## 二、思路
### 1. 枚举最大元素
因为`132`模式中`3`为最大元素，即在中间，因此枚举该元素下标`j`，且要满足：
- 选择左侧元素的最小值`nums[i]`，且`nums[i] < nums[j]`；
- 选择右侧元素，使之满足`nums[k] > nums[i]`且`nums[k] < nums[j]`。

于是，左侧元素非常好确定，即每次移动中间元素时取当前左侧最小元素的值和中间元素的值的最小值；而右侧元素的确定即需要将右侧元素排序，然后选择满足介于左侧元素和中间元素之间的值。如果可以确定下来这两个元素，则存在`132`模式的序列。

对于右侧元素，可以考虑用`multimap`，`multiset`等容器以实现排序的功能。以上数据结构的删除操作的时间复杂度为$O(\log n)$。

```cpp
class Solution {
public:
    bool find132pattern(vector<int>& nums) {
        int n = nums.size();
        if (n < 3) {
            return false;
        }

        int minLeft = nums[0];
        
        multiset<int> s;

        for (int i = 2; i < n; ++i) {
            s.emplace(nums[i]);
        }

        for (int i = 1; i < n - 1; ++i) {
            if (minLeft < nums[i]) {
                for (auto it = s.begin(); it != s.end(); ++it) {
                    if ((*it) >= nums[i]) {
                        break;
                    } else if ((*it) > minLeft) {
                        return true;
                    }
                }
            }
            minLeft = min(minLeft, nums[i]);
            s.erase(s.find(nums[i + 1]));
        }

        return false;
    }
};
```
时间复杂度：$O(\log n)$；
空间复杂度：$O(n)$。

### 2. 枚举最小元素
因为枚举的时最小的元素，因此要在右侧区间内找出两个比该元素大的值`nums[j]`和`nums[k]`，且这两个数满足`j < k` 和 `nums[j] > nums[k]`。如果从左往右找，则需要先找到一个比左侧元素大的，然后再在此元素后找到满足`j < k` 和 `nums[j] > nums[k]`的元素。很显然此时的时间复杂度为$O(n^3)$，因此考虑从后往前找。

从后往前遍历元素时，当遇到了比`nums[i]`更大的元素`nums[k]`，则还需要再找一个比`nums[k]`更大的元素。此时考虑使用**单调栈**，维护的是一个从栈底到栈顶严格递增的序列，当遇到一个比栈顶元素更大的元素时，栈顶元素出栈，若出栈元素比`nums[i]`大，则说明已经找到了一组`i`，`j`，`k`满足`132`序列（出栈元素作为`nums[k]`，左侧元素为`nums[i]`，入栈元素为`nums[j]`）。
```cpp
class Solution {
public:
    bool find132pattern(vector<int>& nums) {
        int n = nums.size();
        if (n < 3) {
            return false;
        }
        stack<int> s;
        int maxRight = INT_MIN;
        s.push(nums[n - 1]);

        for (int i = n - 2; i >= 0; --i) {
            if (nums[i] < maxRight) {
                return true;
            }
            while (!s.empty() && nums[i] > s.top()) {
                maxRight = s.top();
                s.pop();
            }
            s.push(nums[i]);
        }

        return false;
    }
};
```
时间复杂度：$O(n)$；
空间复杂度：$O(n)$。