# 778. 水位上升的泳池中游泳
## 一、题目描述
在一个` N x N `的坐标方格 grid 中，每一个方格的值` grid[i][j] `表示在位置` (i,j) `的平台高度。

现在开始下雨了。当时间为` t `时，此时雨水导致水池中任意位置的水位为` t `。你可以从一个平台游向四周相邻的任意一个平台，但是前提是此时水位必须同时淹没这两个平台。假定你可以瞬间移动无限距离，也就是默认在方格内部游动是不耗时的。当然，在你游泳的时候你必须待在坐标方格里面。

从坐标方格的左上平台` (0，0) `出发。最少耗时多久你才能到达坐标方格的右下平台` (N-1, N-1) `.
```
输入: [[0,2],[1,3]]
输出: 3
解释:
时间为0时，你位于坐标方格的位置为 (0, 0)。
此时你不能游向任意方向，因为四个相邻方向平台的高度都大于当前时间为 0 时的水位。

等时间到达 3 时，你才可以游向平台 (1, 1). 因为此时的水位是 3，坐标方格中的平台没有比水位 3 更高的，所以你可以游向坐标方格中的任意位置
```
```
输入: [[0,1,2,3,4],[24,23,22,21,5],[12,13,14,15,16],[11,17,18,19,20],[10,9,8,7,6]]
输出: 16

解释:
```
$$
\begin{matrix}
\bold{0} & \bold{1} & \bold{2} & \bold{3} & \bold{4} \\
24 & 23 & 22 & 21 & \bold{5} \\
\bold{12} & \bold{13} & \bold{14} & \bold{15} & \bold{16} \\
\bold{11} & 17 & 18 & 19 & 20 \\
\bold{10} & \bold{9} & \bold{8} & \bold{7} & \bold{6}
\end{matrix}
$$
```
最终的路线用加粗进行了标记。
我们必须等到时间为 16，此时才能保证平台 (0, 0) 和 (4, 4) 是连通的
```

## 二、思路
此题与**1631. 最小体力消耗路径**几乎完全一样。`1631`为找出所选择的路径中差值最大的两个相邻元素的差值，本题则为找出所选择的路径中的最大值。
因此，同样可以用二分法求解。

### 1. 二分法
```cpp
class Solution {
private:
    const int DIR[4][2] = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
public:
    int swimInWater(vector<vector<int>>& grid) {
        int n = grid.size();
        int total = n * n;
        int l = 0, r = total - 1;
        int ans = 0;
        while(l <= r){
            int mid = (l + r) >> 1;
            if (mid < grid[0][0]) {
                l = mid + 1;
                continue;
            }

            queue<int> q;
            vector<bool> visited(total, false);
            q.push(0);
            //index = i * n + j;
            visited[0] = true;

            while(!q.empty()){
                int idx = q.front();
                //i = idx / n; j = idx % n;
                q.pop();
                for(int i = 0; i < 4; ++i){
                    int row = idx / n, col = idx % n;
                    int new_row = row + DIR[i][0], new_col = col + DIR[i][1];
                    if(new_row >= 0 && new_row < n && new_col >= 0 && new_col < n && !visited[new_row * n + new_col] && (grid[new_row][new_col] <= mid)){
                        visited[new_row * n + new_col] = true;
                        q.push(new_row * n + new_col);
                    }
                }
            }

            if(visited[total - 1]){
                ans = mid;
                r = mid - 1;
            }else{
                l = mid + 1;
            }

        }
        return ans;
    }
};
```
时间复杂度：$\Omicron (mn \log N)$；
空间复杂度：$\Omicron(mn)$.

### 2. 并查集
思路同`1631`。
```cpp
class UnionFind {
public:
    vector<int> parent;
    vector<int> size;
    int n;
    // 当前连通分量数目
    int setCount;
    
public:
    UnionFind(int _n): n(_n), setCount(_n), parent(_n), size(_n, 1) {
        //iota(parent.begin(), parent.end(), 0);
        for (int i = 0; i < _n; ++i) {
            parent[i] = i;
        }
    }
    
    int find(int x) {
        return parent[x] == x ? x : parent[x] = find(parent[x]);
    }
    
    bool unite(int x, int y) {
        x = find(x);
        y = find(y);
        if (x == y) {
            return false;
        }
        if (size[x] < size[y]) {
            swap(x, y);
        }
        parent[y] = x;
        size[x] += size[y];
        --setCount;
        return true;
    }
    
    bool connected(int x, int y) {
        x = find(x);
        y = find(y);
        return x == y;
    }
};

struct EDGE{
    int x, y, weight;
    EDGE(int _x, int _y, int _w) : x(_x), y(_y), weight(_w) {}
    bool operator< (const EDGE& u) const{
        return weight < u.weight;
    }
};

class Solution {
public:
    int swimInWater(vector<vector<int>>& grid) {
        int m = grid.size();
        int n = grid[0].size();
        //vector<tuple<int, int, int>> edges;
        vector<EDGE> edges;
        for (int i = 0; i < m; ++i) {
            for (int j = 0; j < n; ++j) {
                int id = i * n + j;
                if (i > 0) {
                    edges.emplace_back(id - n, id, max(grid[i][j], grid[i - 1][j]));
                }
                if (j > 0) {
                    edges.emplace_back(id - 1, id, max(grid[i][j], grid[i][j - 1]));
                }
            }
        }
        
        sort(edges.begin(), edges.end());

        UnionFind uf(m * n);
        int ans = 0;
        for (const auto& e: edges) {
            uf.unite(e.x, e.y);
            if (uf.connected(0, m * n - 1)) {
                ans = e.weight;
                break;
            }
        }
        return ans;
    }
};
```