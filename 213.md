# 213. 打家劫舍 II
## 一、题目描述
你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都**围成一圈**，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。

给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，能够偷窃到的最高金额。

```
输入：nums = [2,3,2]
输出：3
解释：你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。
```

## 二、思路
与打家劫舍I（198）完全一样，只不过这里将打家劫舍I的首尾相连了。因此偷了第一个房子就不能偷最后一个房子，偷了最后一个房子就不能偷第一个房子。所以，当选择偷第一个房子时，偷窃的范围是`nums[1...n - 1]`，当选择偷最后一个房子时，偷窃的范围是`nums[2...n]`。因此，此题转化为了两个打家劫舍I的题，只需要在`1`到`n - 1`上计算出能偷窃的最大值，再计算`2`到`n - 2`上能偷窃的最大值，两者取$\max$即得到最终答案。

```cpp
class Solution {
private:
    int myRob(vector<int>& nums, int start, int end) {
        int n = end - start + 1;
        if (n == 1) {
            return nums[start];
        }
        vector<int> dp(n, 0);
        dp[0] = nums[start];
        dp[1] = max(nums[start], nums[start + 1]);
        for (int i = 2; i < n; ++i) {
            dp[i] = max(dp[i - 2] + nums[i + start], dp[i - 1]);
        }

        return dp[n - 1];
    }
public:
    int rob(vector<int>& nums) {
        int n = nums.size();
        if(n == 0){
            return 0;
        }else if(n == 1){
            return nums[0];
        }

        return max(myRob(nums, 0, n - 2), myRob(nums, 1, n - 1));
        
    }
};
```
时间复杂度：$O(n)$，
空间复杂度：$O(n)$。