# 面试题 17.22. 单词转换
## 一、题目描述
给定字典中的两个词，长度相等。写一个方法，把一个词转换成另一个词， 但是一次只能改变一个字符。每一步得到的新词都必须能在字典中找到。

编写一个程序，返回一个可能的转换序列。如有多个可能的转换序列，你可以返回任何一个。

示例 1:
```
输入:
beginWord = "hit",
endWord = "cog",
wordList = ["hot","dot","dog","lot","log","cog"]

输出:
["hit","hot","dot","lot","log","cog"]
```
## 二、思路
很显然此题考察的是DFS，但是需注意，此题不需回溯。假设某一条路径需要经过字符串`str`，且该路径无法得到一个成功的转换实例，那么当用其他路路径达到该字符串时，仍然将无法得到一个成功的转换，因此无需将`visited[i]`回置，也就是剪枝过程。

```cpp
class Solution {
private:
    vector<string> res;
    bool check(string a, string b) {
        bool trans = false;
        int n = a.size();
        for (int i = 0; i < n; ++i) {
            if (a[i] != b[i]) {
                if(!trans) {
                    trans = true;
                } else {
                    return false;
                }
            }
        }
        return trans;
    }
    bool dfs(vector<int>& visited, string& beginWord, string& endWord, vector<string>& wordList) {
        if (beginWord == endWord) {
            return true;
        }
        for (int i = 0; i < wordList.size(); ++i) {
            if (check(wordList[i], beginWord) && !visited[i]) {
                visited[i] = 1;
                res.emplace_back(wordList[i]);
                if (dfs(visited, wordList[i], endWord, wordList)) {
                    return true;
                }
                res.pop_back();
            }
        }
        return false;
    }
    
public:
    vector<string> findLadders(string beginWord, string endWord, vector<string>& wordList) {
        int n = wordList.size();
        int end = -1;
        for(int i = 0; i < n; ++i) {
            if(wordList[i] == endWord) {
                end = i;
            }
        }
        if(end == -1) {
            return vector<string>{};
        }

        vector<int> visited(n, 0);
        res.emplace_back(beginWord);
        if(dfs(visited, beginWord, endWord, wordList)) {
            return res;
        }

        return vector<string>{};

    }
};
```
时间复杂度：$O(n^2)$；
空间复杂度：$O(n)$。