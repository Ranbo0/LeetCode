# 53. 最大子序列和
## 一、题目描述
给定一个整数数组 `nums` ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
## 二、思路
令`f(i)`表示以第`i`个数结尾的连续子序列的最大和，因此最大子序列和很显然就是$$\max_{{0\le i\le n}}\{f(i)\}$$
考虑第`i`个元素，我们可以考虑令`nums[i]`与前面的`f(i - 1)`组合得到`f(i)`，也可以让`nums[i]`一个元素组成`f(i)`。因此，状态转移方程即为：
$$f(i)=\max\left\{f(i-1)+nums[i], nums[i]\right\}$$
考虑到`f(i)`只和`f(i-1)`相关，于是我们可以只用一个变量`pre`来维护对于当前`f(i)`的`f(i−1)`的值是多少，从而让空间复杂度降低到`O(1)`，这有点类似「滚动数组」的思想。

```cpp
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int pre = 0, maxAns = nums[0];
        for (const auto &x: nums) {
            pre = max(pre + x, x);
            maxAns = max(maxAns, pre);
        }
        return maxAns;
    }
};
```
或者用另一种dp思路，考虑`nums[i]`结尾的最大子序列，要么是和前面结合形成`f(i) + nums[i]`，要么是自成一个子序列形成`nums[i]`。而是否需要和前一项相加只需要看`f(i)`是否大于`0`，如果大于`0`则和前面结合形成`f(i) + nums[i]`得到的子序列和更大，否则自成一个子序列的子序列和更大。

```cpp
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int n = nums.size();
        for (int i = 1; i < n; ++i) {
            nums[i] = nums[i] + max(0, nums[i - 1]);
        }

        int maxCnt = INT_MIN;
        for (int i = 0; i < n; ++i) {
            maxCnt = max(maxCnt, nums[i]);
        }

        return maxCnt;
        
    }
};
```

时间复杂度：$O(n)$；
空间复杂度：$O(1)$.

## 三、总结
遇到了"最长"，"连续"这样的词之后应该第一时间想到dp。